---
title: Tables and Numbers for Manuscript
author:
- name: redacted redacted
  num: a
address:
- num: a
  org: redacted redacted
corres: "corres"
# presentaddress: This is sample for present address text this is sample for present address text
authormark: redacted
articletype: Research article
abstract: "redacted"
keywords: redacted
bibliography: bibfile.bib
output:
  rticles::sim_article:
    keep_tex: true
longtable: true
header-includes:
  - \usepackage{bm}
  - \usepackage{booktabs}
  - \usepackage{array}
  - \usepackage{multirow}
  - \usepackage{wrapfig}
  - \usepackage{float}
  - \usepackage{colortbl}
  - \usepackage{pdflscape}
  - \usepackage{tabu}
  - \usepackage{threeparttable}
  - \usepackage{threeparttablex}
  - \usepackage{makecell}
  - \usepackage{enumitem}
  - \usepackage{longtable}
  - \usepackage{tikz}
  - \usetikzlibrary{matrix,calc,shapes}
  - \tikzset{
    treenode/.style = {shape=rectangle, rounded corners,
    draw, anchor=center,
    text width=8em, align=center,
    top color=white, bottom color=blue!20,
    inner sep=1ex},
    decision/.style = {treenode, diamond, inner sep=0pt},
    root/.style     = {treenode, font=\Large,
    bottom color=red!30},
    env/.style      = {treenode, font=\ttfamily\normalsize},
    finish/.style   = {root, bottom color=green!40},
    dummy/.style    = {circle,draw}
    }
editor_options:
  markdown:
    wrap: 72
---

# Results
```{r, echo=FALSE, message=FALSE, message=FALSE, warning=FALSE}
library(here)
library(tidyverse)
library(here)
library(knitr)
library(fpCompare)
options(kableExtra.latex.load_packages = FALSE)
library(kableExtra)
```


```{r read stuff, echo=FALSE, warning=FALSE, message=FALSE}
library(mvtnorm)
first_tab <- readRDS(here("dat", "first_tab.rds"))
source(here("R", "table_format_functions.R"))
source(here("R", "1_conditional_probability_functions.R"))
source(here("R", "2_design_functions.R"))
source(here("R", "3_optimization_methods.R"))

dlist_names <- c(
  "optD_single_stage",
  "optD_no_futility_fixed_c",
  "optD_no_futility",
  "optD_nonbinding_futility",
  "optD_fully_sequential",
  "optD_closed_testing"
  )

dlist_tab1 <- list()
tlist <- list()
for (i in 1:nrow(first_tab)){
dlist <- first_tab[i,dlist_names]
dlist_tab1 <- c(dlist_tab1, dlist)
for (di in seq_along(dlist)){
  ss <- names(dlist)[[di]] == "optD_single_stage"
  d <- dlist[[di]][[1]]
  ccc_ <-  ccc_wrt_nmax(if (ss)
    d$cc
    else
      d$ccc, d$maxn, d$n, ss)
  tlist[[length(tlist)+1]] <- tibble(
    beta = d$type_II_error,
    Delta = d$Delta,
    `Design` = switch(
      names(dlist)[[di]],
      "optD_single_stage" = "1",
      "optD_no_futility_fixed_c" = "2",
      "optD_no_futility" = "3",
      "optD_nonbinding_futility" = "4",
      "optD_fully_sequential" = "5",
      "optD_closed_testing" = "6"
    ),
    # `$c_{1, T}$` =  ccc_[[1]][["T"]],
    # `$c_{1, P}$` =  ccc_[[1]][["P"]],
    # `$c_{1, C}$` =  ccc_[[1]][["C"]],
    # `$c_{2, T}$` =  ccc_[[2]][["T"]],
    # `$c_{2, P}$` =  ccc_[[2]][["P"]],
    # `$c_{2, C}$` =  ccc_[[2]][["C"]],
    # `$n_{max}$` = d$maxn,
    `$n_{1, T}$` =  if (ss)
      d$n[[1]][["T"]]
    else
      d$cumn[[1]][["T"]],
    `$n_{1, P}$` =  if (ss)
      d$n[[1]][["P"]]
    else
      d$cumn[[1]][["P"]],
    `$n_{1, C}$` =  if (ss)
      d$n[[1]][["C"]]
    else
      d$cumn[[1]][["C"]],
    `$n_{2, T}$` =  if (ss)
      NA_real_
    else
      d$cumn[[2]][["T"]],
    `$n_{2, P}$` =  if (ss)
      NA_real_
    else
      d$cumn[[2]][["P"]],
    `$n_{2, C}$` =  if (ss)
      NA_real_
    else
      d$cumn[[2]][["C"]],
    `$N^{}_{H_1}$` = d$ASN$H1,
    `$CP_{\\min}$` = d$min_conditional_power,
    `$b_{1, TP, f}$` = case_when(format(ifelse(ss, NA_real_, d$b[[1]][["TP"]][["futility"]]), digits = 2) == "NA" ~ "",
                                 format(ifelse(ss, NA_real_, d$b[[1]][["TP"]][["futility"]]), digits = 2) == "Inf" ~ "$\\infty$",
                                 format(ifelse(ss, NA_real_, d$b[[1]][["TP"]][["futility"]]), digits = 2) == "-Inf" ~ "$-\\infty$",
                                 TRUE ~ format(ifelse(ss, NA_real_, round(d$b[[1]][["TP"]][["futility"]], digits=2) ), snmall = 2)),
    `$b_{1, TP, e}$` = d$b[[1]][["TP"]][["efficacy"]],
    `$b_{2, TP, e}$` = ifelse(ss, NA_real_, d$b[[2]][["TP"]][["efficacy"]]),
    `$b_{1, TC, f}$` = case_when(format(ifelse(ss, NA_real_, d$b[[1]][["TC"]][["futility"]]), digits = 2) == "NA" ~ "",
                                 format(ifelse(ss, NA_real_, d$b[[1]][["TC"]][["futility"]]), digits = 2) == "Inf" ~ "$\\infty$",
                                 format(ifelse(ss, NA_real_, d$b[[1]][["TC"]][["futility"]]), digits = 2) == "-Inf" ~ "$-\\infty$",
                                 TRUE ~ format(ifelse(ss, NA_real_, round(d$b[[1]][["TC"]][["futility"]], digits=2)), snmall = 2)),
    `$b_{1, TC, e}$` = d$b[[1]][["TC"]][["efficacy"]],
    `$b_{2, TC, e}$` = ifelse(ss, NA_real_, d$b[[2]][["TC"]][["efficacy"]])
  )
}
}
first_tab_tib <- bind_rows(tlist)

first_tab_tib <- bind_rows(tlist)
first_tab_tib <- rbind(
first_tab_tib %>% filter(beta %==% .2, Delta%==%.3),
first_tab_tib %>% filter(beta %==% .1, Delta%==%.3)
# first_tab_tib %>% filter(beta %==% .05, Delta %==% .1)
) %>% select(-c("beta", "Delta"))

```

```{r tables, echo=FALSE}
options(knitr.kable.NA = '')
kbl(
  first_tab_tib,
  escape = FALSE,
  booktabs = TRUE,
  linesep = "",
  digits = c(1, rep(0, 6), 0, rep(2, 7)),
  align = 'c',
  caption = "\\label{tab_1}Operating characteristics of various optimal designs. See Table \\ref{design_table} for an overview of the differences between the presented designs. $\\delta = 0.6, \\Delta = 0.3, \\sigma_T = \\sigma_P = \\sigma_C = 1$. $N_{H_1} = N_{H_1^{TP} \\cap H_1^{TC}}$ denotes the average sample size under the alternative hypothesis.  $CP_{\\min}$ denotes the minimum conditional power."
) %>% 
  pack_rows(index = c(
    "$\\\\bm{1-\\\\beta = 0.8}$" = 6,
    "$\\\\bm{1-\\\\beta = 0.9}$" = 6
    # "$\\\\bm{1-\\\\beta = 0.95, \\\\Delta = 0.1}$" = 6
),
escape = FALSE) %>%
  column_spec(c(1:8, 10:15), width = ".735cm") %>% 
  column_spec(9, width = ".735cm") %>% 
  kable_styling(latex_options = "H")
```




[...]
We observe the largest relative improvement when moving from the single-stage
design 1 to the two-stage design 2, a relative reduction of `r scales::percent(1 - dlist_tab1$optD_no_futility_fixed_c[[1]]$ASN$H1 / dlist_tab1$optD_single_stage[[1]]$ASN$H1, accuracy=.1)` (resp. `r scales::percent(1 - dlist_tab1[[which(names(dlist_tab1)=="optD_no_futility_fixed_c")[2]]][[1]]$ASN$H1 / dlist_tab1[[which(names(dlist_tab1)=="optD_single_stage")[2]]][[1]]$ASN$H1, accuracy=.1)`) in average sample size. Design 2 uses the same between-group allocation ratios
as the single-stage design and an between-stage allocation ratio of 1. When this restriction is abolished in design 3,
we can achieve a relative reduction in average sample size of `r scales::percent(1 - dlist_tab1$optD_no_futility[[1]]$ASN$H1 / dlist_tab1$optD_no_futility_fixed_c[[1]]$ASN$H1, accuracy=.1)` (resp. `r scales::percent(1 - dlist_tab1[[which(names(dlist_tab1)=="optD_no_futility")[2]]][[1]]$ASN$H1 / dlist_tab1[[which(names(dlist_tab1)=="optD_no_futility_fixed_c")[2]]][[1]]$ASN$H1, accuracy=.1)`) compared to design 2. Design 4 is the first
design to include futility boundaries. The boundaries are technically nonbinding and are not used
for type I error recycling. However, the calculation assumes that the boundaries are adhered to
(otherwise, there would be no difference between design 3 and 4). Compared to the previous design,
this achieves a relative improvement of `r scales::percent(1 - dlist_tab1$optD_nonbinding_futility[[1]]$ASN$H1 / dlist_tab1$optD_no_futility[[1]]$ASN$H1, accuracy=.1)` (resp. `r scales::percent(1 - dlist_tab1[[which(names(dlist_tab1)=="optD_nonbinding_futility")[2]]][[1]]$ASN$H1 / dlist_tab1[[which(names(dlist_tab1)=="optD_no_futility")[2]]][[1]]$ASN$H1, accuracy=.1)`).
[...]



[...]
Compared to design 4, we observe
a relative reduction of `r scales::percent(1 - dlist_tab1$optD_fully_sequential[[1]]$ASN$H1 / dlist_tab1$optD_nonbinding_futility[[1]]$ASN$H1, accuracy=.1)` (resp. `r scales::percent(1 - dlist_tab1[[which(names(dlist_tab1)=="optD_fully_sequential")[2]]][[1]]$ASN$H1 / dlist_tab1[[which(names(dlist_tab1)=="optD_nonbinding_futility")[2]]][[1]]$ASN$H1, accuracy=.1)`) in average sample size. Further, the design based on the closed testing
principle (design 6) offers a relative improvement of `r scales::percent(1 - dlist_tab1$optD_closed_testing[[1]]$ASN$H1 / dlist_tab1$optD_fully_sequential[[1]]$ASN$H1, accuracy=.1)` (resp. `r scales::percent(1 - dlist_tab1[[which(names(dlist_tab1)=="optD_closed_testing")[2]]][[1]]$ASN$H1 / dlist_tab1[[which(names(dlist_tab1)=="optD_fully_sequential")[2]]][[1]]$ASN$H1, accuracy=.1)`) over the fully sequential design 5.
[...]



[...]
Overall, design 6 achieves an improvement in average sample size over design 2 of `r scales::percent(1 - dlist_tab1[[which(names(dlist_tab1)=="optD_nonbinding_futility")[1]]][[1]]$ASN$H1 / dlist_tab1[[which(names(dlist_tab1)=="optD_no_futility_fixed_c")[1]]][[1]]$ASN$H1, accuracy=.1)` (`r scales::percent(1 - dlist_tab1[[which(names(dlist_tab1)=="optD_nonbinding_futility")[2]]][[1]]$ASN$H1 / dlist_tab1[[which(names(dlist_tab1)=="optD_no_futility_fixed_c")[2]]][[1]]$ASN$H1, accuracy=.1)`).
[...]


[...]
The efficiency gain from the single-stage
design 1 to the first multi-stage design 2 could be interpreted as a
degenerate case of this principle: the rejection probability at interim in the
single-stage design is 0%, whereas the rejection probabilities in design 2 are
`r scales::percent(calc_prob_TC1E(D=dlist_tab1$optD_no_futility_fixed_c[[1]]), accuracy=.1)` and
`r scales::percent(dlist_tab1$optD_no_futility_fixed_c[[1]]$finalStateProbs$H1$TP1E_TC1E, accuracy=.1)`
respectively for the first and for both hypotheses at interim (respectively `r scales::percent(calc_prob_TC1E(D=dlist_tab1[[which(names(dlist_tab1)=="optD_no_futility_fixed_c")[2]]][[1]]))` and `r scales::percent(dlist_tab1[[which(names(dlist_tab1)=="optD_no_futility_fixed_c")[2]]][[1]]$finalStateProbs$H1$TP1E_TC1E, accuracy=.1)` for the scenario with $1-\beta = 0.9$). In design 3, these probabilities
increase to `r scales::percent(calc_prob_TC1E(D=dlist_tab1$optD_no_futility[[1]]), accuracy=.1)` and
`r scales::percent(dlist_tab1$optD_no_futility[[1]]$finalStateProbs$H1$TP1E_TC1E, accuracy=.1)` (resp. `r scales::percent(calc_prob_TC1E(D=dlist_tab1[[which(names(dlist_tab1)=="optD_no_futility")[2]]][[1]]), accuracy=.1)` and
`r scales::percent(dlist_tab1[[which(names(dlist_tab1)=="optD_no_futility")[2]]][[1]]$finalStateProbs$H1$TP1E_TC1E, accuracy=.1)`). The
maximum of these probabilities is reached in design 6, with respective values of
`r scales::percent(calc_prob_TC1E(D=dlist_tab1$optD_closed_testing[[1]]), accuracy=.1)` and
`r scales::percent(dlist_tab1$optD_closed_testing[[1]]$finalStateProbs$H1$TP1E_TC1E, accuracy=.1)`
(resp. `r scales::percent(calc_prob_TC1E(D=dlist_tab1[[which(names(dlist_tab1)=="optD_closed_testing")[2]]][[1]]), accuracy=.1)` and
`r scales::percent(dlist_tab1[[which(names(dlist_tab1)=="optD_closed_testing")[2]]][[1]]$finalStateProbs$H1$TP1E_TC1E, accuracy=.1)`).
[...]


## Including weighted hypotheses in the objective function
\label{null weight}

```{r, echo=FALSE, warning=FALSE, message=FALSE}
second_tab <- readRDS(here("dat", "second_tab.rds"))

dlist_names <- c(
  # "optD_single_stage",
  # "optD_no_futility_fixed_c",
  # "optD_no_futility",
  # "optD_nonbinding_futility",
  # "optD_fully_sequential",
  "optD_closed_testing"
  )
dlist <- apply(second_tab[,dlist_names], 1, as.list) %>% 
  unlist(recursive = FALSE)
dlist_names <- names(dlist)
dlist[[1]] <- dlist_tab1[[6]][[1]]
dlist[[2]] <- dlist_tab1[[12]][[1]]
dlist <- dlist[-c(21, 22)]


dlist_tab2 <- dlist
tlist <- list()
for (di in seq_along(dlist)){
  ss <- names(dlist)[[di]] == "optD_single_stage"
  d <- dlist[[di]]
  ccc_ <-  ccc_wrt_nmax(if(ss)d$cc else d$ccc, d$maxn, d$n, ss)
  tlist[[di]] <- tibble(
    beta = d$type_II_error,
    Delta = d$Delta,
  # `Design` = switch(names(dlist)[[di]],
  # "optD_single_stage"="SS",
  # "optD_no_futility_fixed_c"="FC",
  # "optD_no_futility"="NF",
  # "optD_nonbinding_futility"="NB",
  # "optD_fully_sequential"="Sq",
  # "optD_closed_testing"="Cl"),
  `$\\lambda$` = d$lambda,
  # `$c_{1, T}$` =  ccc_[[1]][["T"]],
  # `$c_{1, P}$` =  ccc_[[1]][["P"]],
  # `$c_{1, C}$` =  ccc_[[1]][["C"]],
  # `$c_{2, T}$` =  ccc_[[2]][["T"]],
  # `$c_{2, P}$` =  ccc_[[2]][["P"]],
  # `$c_{2, C}$` =  ccc_[[2]][["C"]],
  # `$n_{max}$` = d$maxn,
  `$n_{1, T}$` =  if(ss)d$n[[1]][["T"]] else d$cumn[[1]][["T"]],
  `$n_{1, P}$` =  if(ss)d$n[[1]][["P"]] else d$cumn[[1]][["P"]],
  `$n_{1, C}$` =  if(ss)d$n[[1]][["C"]] else d$cumn[[1]][["C"]],
  `$n_{2, T}$` =  if(ss)NA_real_ else d$cumn[[2]][["T"]],
  `$n_{2, P}$` =  if(ss)NA_real_ else d$cumn[[2]][["P"]],
  `$n_{2, C}$` =  if(ss)NA_real_ else d$cumn[[2]][["C"]],
  `$N^{}_{H_0}$` = d$ASN$H0,
  `$N^{}_{H_1}$` = d$ASN$H1,
  # `ASNP` = d$ASNP$H1,
  `$g_{\\lambda, \\kappa}(D)$` = d$objective_val,
  `$CP_{\\min}$` = d$min_conditional_power,
  # `$b_{1, TP, f}$` = ifelse(ss, NA_real_,d$b[[1]][["TP"]][["futility"]]),
  # `$b_{1, TP, e}$` = d$b[[1]][["TP"]][["efficacy"]],
  # `$b_{2, TP, e}$` = ifelse(ss, NA_real_,d$b[[2]][["TP"]][["efficacy"]]),
  # `$b_{1, TC, f}$` = ifelse(ss, NA_real_,d$b[[1]][["TC"]][["futility"]]),
  # `$b_{1, TC, e}$` = d$b[[1]][["TC"]][["efficacy"]],
  # `$b_{2, TC, e}$` = ifelse(ss, NA_real_,d$b[[2]][["TC"]][["efficacy"]]),
  `$p_{TP, f}$` =  calc_futility_prob(D=d, hypothesis = "H1", groups = "TP"),
  `$p_{TC, f}$` =  calc_futility_prob(D=d, hypothesis = "H1", groups = "TC")
  )
}
second_tab_tib <- bind_rows(tlist)

second_tab_tib <- rbind(
second_tab_tib %>% filter(beta %==% .2, Delta%==%.3),
second_tab_tib %>% filter(beta %==% .1, Delta%==%.3)
# second_tab_tib %>% filter(beta %==% .05, Delta %==% .1)
) %>% select(-c("beta", "Delta"))


kbl(second_tab_tib, escape = FALSE,  booktabs = TRUE,  linesep = "",
      digits = c(2, rep(0, 9),  2, rep(3, 2)), align='c', caption = "\\label{tab_2}Operating characteristics of optimal designs with different weighting factors for the null hypothesis. Results are presented for design 6 (cf. Table \\ref{design_table}).  $\\delta = 0.6, \\Delta = 0.3, \\sigma_T = \\sigma_P = \\sigma_C = 1$. $N_{H_i} = N_{H_i^{TP} \\cap H_i^{TC}}$ and $N_{H_i}^P = N_{H_i^{TP} \\cap H_i^{TC}}^P$ denote the overall / placebo group average sample size under the respective hypotheses for $i \\in \\{0,1\\}$. $p_{TP, f}$ and $p_{TC, f}$ denote the probability under the alternative that the respective test statistic falls below the respective futility boundary. $CP_{\\min}$ denotes the minimum conditional power.") %>%  pack_rows(index = c(
    "$\\\\bm{1-\\\\beta = 0.8}$" = 10,
    "$\\\\bm{1-\\\\beta = 0.9}$" = 10
    # "$\\\\bm{1-\\\\beta = 0.95, \\\\Delta = 0.1}$" = 6
), escape = FALSE) %>% 
  kable_styling(latex_options="H")
```


[...]
 `r paste0("$\\mu_{1, TP, H1} - \\mu_{1, TP, H0} \\approx ", format(round(dlist_tab2[[3]]$mu_vec$H1[1] - dlist_tab2[[3]]$mu_vec$H0[1], digits = 1)), "$")`, while
for the latter test statistic the difference is around
`r paste0("$\\mu_{1, TP, H1} - \\mu_{1, TP, H0} \\approx ", format(round(dlist_tab2[[3]]$mu_vec$H1[3] - dlist_tab2[[3]]$mu_vec$H0[3], digits = 1)), "$")` (resp. `r paste0("$\\mu_{1, TP, H1} - \\mu_{1, TP, H0} \\approx ", format(round(dlist_tab2[[12]]$mu_vec$H1[1] - dlist_tab2[[12]]$mu_vec$H0[1], digits = 1)), "$")` and `r paste0("$\\mu_{1, TP, H1} - \\mu_{1, TP, H0} \\approx ", format(round(dlist_tab2[[12]]$mu_vec$H1[3] - dlist_tab2[[12]]$mu_vec$H0[3], digits = 1)), "$")`).
[...]


## Penalizing the sample size of the placebo group
\label{kappa}
```{r, echo=FALSE, warning=FALSE, message=FALSE}
third_tab <- readRDS(here("dat", "third_tab.rds"))

dlist_names <- c(
  # "optD_single_stage",
  # "optD_no_futility_fixed_c",
  # "optD_no_futility",
  # "optD_nonbinding_futility",
  # "optD_fully_sequential",
  "optD_closed_testing"
  )
dlist <- apply(third_tab[,dlist_names], 1, as.list) %>% 
  unlist(recursive = FALSE)


dlist <- c(
           optD_no_futility_fixed_c=dlist_tab1[[2]],
           optD_no_futility_fixed_c=dlist_tab1[[8]],
           optD_closed_testing=dlist_tab1[[6]],
           optD_closed_testing=dlist_tab1[[12]],
           
           dlist[3:14]

           # optD_no_futility_fixed_c=dlist_tab1[[2]],
           # optD_closed_testing=dlist_tab1[[6]],
           # dlist[1:7]
           
           # optD_no_futility_fixed_c=dlist_tab1[[14]],
           # optD_closed_testing=dlist_tab1[[18]],
           # dlist[15:21]
           # 
           )
dlist_names <- names(dlist)
dlist_tab3 <- dlist[order(sapply(dlist, function(x)x$type_II_error),sapply(dlist, function(x)x$kappa), sapply(dlist, function(x)length(x$opt$solution)), decreasing = c(TRUE, FALSE, FALSE))]
tlist <- list()
for (di in seq_along(dlist)){
  ss <- names(dlist)[[di]] == "optD_single_stage"
  d <- dlist[[di]]
  ccc_ <-  ccc_wrt_nmax(if(ss)d$cc else d$ccc, d$maxn, d$n, ss)
  tlist[[di]] <- tibble(
    beta = d$type_II_error,
    Delta = d$Delta,
    `Design` = switch(
      names(dlist)[[di]],
      "optD_single_stage" = "1",
      "optD_no_futility_fixed_c" = "2",
      "optD_no_futility" = "3",
      "optD_nonbinding_futility" = "4",
      "optD_fully_sequential" = "5",
      "optD_closed_testing" = "6"
    ),
  # `$\\lambda$` = d$lambda,
  `$\\kappa$` = d$kappa,
  # `$c_{1, T}$` =  ccc_[[1]][["T"]],
  # `$c_{1, P}$` =  ccc_[[1]][["P"]],
  # `$c_{1, C}$` =  ccc_[[1]][["C"]],
  # `$c_{2, T}$` =  ccc_[[2]][["T"]],
  # `$c_{2, P}$` =  ccc_[[2]][["P"]],
  # `$c_{2, C}$` =  ccc_[[2]][["C"]],
  # `$n_{max}$` = d$maxn,
  `$n_{1, T}$` =  if(ss)d$n[[1]][["T"]] else d$cumn[[1]][["T"]],
  `$n_{1, P}$` =  if(ss)d$n[[1]][["P"]] else d$cumn[[1]][["P"]],
  `$n_{1, C}$` =  if(ss)d$n[[1]][["C"]] else d$cumn[[1]][["C"]],
  `$n_{2, T}$` =  if(ss)NA_real_ else d$cumn[[2]][["T"]],
  `$n_{2, P}$` =  if(ss)NA_real_ else d$cumn[[2]][["P"]],
  `$n_{2, C}$` =  if(ss)NA_real_ else d$cumn[[2]][["C"]],
  `$N^{}_{H_0}$` = d$ASN$H0,
  `$N^{}_{H_1}$` = d$ASN$H1,
  `$N^{P}_{H_0}$` = d$ASNP$H0,
  `$N^{P}_{H_1}$` = d$ASNP$H1,
  # `ASNP` = d$ASNP$H1,
  `$g_{\\lambda, \\kappa}(D)$` = d$objective_val,
  `$CP_{\\min}$` = d$min_conditional_power
  # `$b_{1, TP, f}$` = ifelse(ss, NA_real_,d$b[[1]][["TP"]][["futility"]]),
  # `$b_{1, TP, e}$` = d$b[[1]][["TP"]][["efficacy"]],
  # `$b_{2, TP, e}$` = ifelse(ss, NA_real_,d$b[[2]][["TP"]][["efficacy"]]),
  # `$b_{1, TC, f}$` = ifelse(ss, NA_real_,d$b[[1]][["TC"]][["futility"]]),
  # `$b_{1, TC, e}$` = d$b[[1]][["TC"]][["efficacy"]],
  # `$b_{2, TC, e}$` = ifelse(ss, NA_real_,d$b[[2]][["TC"]][["efficacy"]]),
  # `$p_{TP, f}$` =  calc_futility_prob(D=d, hypothesis = "H1", groups = "TP"),
  # `$p_{TC, f}$` =  calc_futility_prob(D=d, hypothesis = "H1", groups = "TC")
  )
}


third_tab_tib <- bind_rows(tlist)
third_tab_tib <- rbind(
third_tab_tib %>% filter(beta %==% .2, Delta%==%.3) %>% arrange(Design, `$\\kappa$`),
third_tab_tib %>% filter(beta %==% .1, Delta%==%.3) %>% arrange(Design, `$\\kappa$`)
) %>% select(-c("beta", "Delta", "Design"))
```

[...]
When optimized for `r paste0("$\\kappa =" , dlist_tab3[[6]]$kappa ,"$")`, design 6
achieves a similar average placebo group sample size to design 2, while maintaining a decrease in
overall average sample size of about `r scales::percent(1 - dlist_tab3[[6]]$ASN$H1 / dlist_tab3[[1]]$ASN$H1, accuracy=.1)` (resp. `r scales::percent(1 - dlist_tab3[[14]]$ASN$H1 / dlist_tab3[[9]]$ASN$H1, accuracy=.1)`).
[...]

```{r, echo=FALSE, warning=FALSE, message=FALSE, fig.pos="H"}
kbl(third_tab_tib, escape = FALSE,  booktabs = TRUE,  linesep = "",
      digits = c(2, rep(0, 6), rep(0, 4), 0, 2), align='c', caption = "\\label{tab_3}Operating characteristics of optimal designs with different penalty factors for the placebo group sample size. See Table \\ref{design_table} for an overview of the differences between design 2 and 6. $\\delta = 0.6, \\Delta = 0.3, \\sigma_T = \\sigma_P = \\sigma_C = 1$. $N_{H_i} = N_{H_i^{TP} \\cap H_i^{TC}}$ and $N_{H_i}^P = N_{H_i^{TP} \\cap H_i^{TC}}^P$ denote the overall / placebo group average sample size under the respective hypotheses for $i \\in \\{0,1\\}$. $CP_{\\min}$ denotes the minimum conditional power. Optimization was performed with all weight on the alternative hypotheis, i.e. $\\lambda = 1$.") %>%  pack_rows(index = c(
    "$\\\\bm{1-\\\\beta = 0.8,\\\\text{ design 2}}$" = 1,
    "$\\\\bm{1-\\\\beta = 0.8,\\\\text{ design 6}}$" = 7,
    "$\\\\bm{1-\\\\beta = 0.9,\\\\text{ design 2}}$" = 1,
    "$\\\\bm{1-\\\\beta = 0.9,\\\\text{ design 6}}$" = 7
    # "$\\\\bm{1-\\\\beta = 0.95, \\\\Delta = 0.1}$" = 9
), escape = FALSE) %>% 
  kable_styling(latex_options="H")
```

\newpage

## Combining hypothesis weighting and placebo penalization

```{r, echo=FALSE, warning=FALSE, message=FALSE}
fourth_tab <- readRDS(here("dat", "fourth_tab.rds"))


good_design <- fourth_tab$optD_closed_testing[apply(fourth_tab["optD_closed_testing"],1,
                                           function(x)x[[1]]$kappa %==% 1 &
                                             x[[1]]$lambda %==% .7)][[1]]

dlist_names <- c(
  # "optD_single_stage",
  # "optD_no_futility_fixed_c",
  # "optD_no_futility",
  # "optD_nonbinding_futility",
  # "optD_fully_sequential",
  "optD_closed_testing"
  )
dlist <- apply(fourth_tab[,dlist_names], 1, as.list) %>% 
  unlist(recursive = FALSE)

dlist <- c(
  optD_no_futility_fixed_c=dlist_tab1[[2]],
  optD_closed_testing=dlist_tab1[[6]],
  dlist[-1]
  )

  
dlist_names <- names(dlist)
dlist_names[dlist_names==""] <- "optD_no_futility_fixed_c"
names(dlist) <- dlist_names
dlist_tab4 <- dlist[order(sapply(dlist, function(x)x$type_II_error),sapply(dlist, function(x)x$kappa), sapply(dlist, function(x)length(x$opt$solution)), decreasing = c(TRUE, FALSE, FALSE))]
tlist <- list()
for (di in seq_along(dlist)){
  ss <- names(dlist)[[di]] == "optD_single_stage"
  d <- dlist[[di]]
  ccc_ <-  ccc_wrt_nmax(if(ss)d$cc else d$ccc, d$maxn, d$n, ss)
  tlist[[di]] <- tibble(
    beta = d$type_II_error,
    Delta = d$Delta,
    `Design` = switch(
      names(dlist)[[di]],
      "optD_single_stage" = "1",
      "optD_no_futility_fixed_c" = "2",
      "optD_no_futility" = "3",
      "optD_nonbinding_futility" = "4",
      "optD_fully_sequential" = "5",
      "optD_closed_testing" = "6"
    ),
  # `$\\lambda$` = d$lambda,
  `$\\lambda$` = d$lambda,
  `$\\kappa$` = d$kappa,
  # `$c_{1, T}$` =  ccc_[[1]][["T"]],
  # `$c_{1, P}$` =  ccc_[[1]][["P"]],
  # `$c_{1, C}$` =  ccc_[[1]][["C"]],
  # `$c_{2, T}$` =  ccc_[[2]][["T"]],
  # `$c_{2, P}$` =  ccc_[[2]][["P"]],
  # `$c_{2, C}$` =  ccc_[[2]][["C"]],
  # `$n_{max}$` = d$maxn,
  `$n_{1, T}$` =  if(ss)d$n[[1]][["T"]] else d$cumn[[1]][["T"]],
  `$n_{1, P}$` =  if(ss)d$n[[1]][["P"]] else d$cumn[[1]][["P"]],
  `$n_{1, C}$` =  if(ss)d$n[[1]][["C"]] else d$cumn[[1]][["C"]],
  `$n_{2, T}$` =  if(ss)NA_real_ else d$cumn[[2]][["T"]],
  `$n_{2, P}$` =  if(ss)NA_real_ else d$cumn[[2]][["P"]],
  `$n_{2, C}$` =  if(ss)NA_real_ else d$cumn[[2]][["C"]],
  `$N^{}_{H_0}$` = d$ASN$H0,
  `$N^{}_{H_1}$` = d$ASN$H1,
  `$N^{P}_{H_0}$` = d$ASNP$H0,
  `$N^{P}_{H_1}$` = d$ASNP$H1,
  # `ASNP` = d$ASNP$H1,
  `$g_{\\lambda, \\kappa}(D)$` = d$objective_val,
  `$CP_{\\min}$` = d$min_conditional_power
  # `$b_{1, TP, f}$` = ifelse(ss, NA_real_,d$b[[1]][["TP"]][["futility"]]),
  # `$b_{1, TP, e}$` = d$b[[1]][["TP"]][["efficacy"]],
  # `$b_{2, TP, e}$` = ifelse(ss, NA_real_,d$b[[2]][["TP"]][["efficacy"]]),
  # `$b_{1, TC, f}$` = ifelse(ss, NA_real_,d$b[[1]][["TC"]][["futility"]]),
  # `$b_{1, TC, e}$` = d$b[[1]][["TC"]][["efficacy"]],
  # `$b_{2, TC, e}$` = ifelse(ss, NA_real_,d$b[[2]][["TC"]][["efficacy"]]),
  # `$p_{TP, f}$` =  calc_futility_prob(D=d, hypothesis = "H1", groups = "TP"),
  # `$p_{TC, f}$` =  calc_futility_prob(D=d, hypothesis = "H1", groups = "TC")
  )
}
fourth_tab_tib <- bind_rows(tlist) %>%
  arrange(beta, Design, desc(`$\\lambda$`), `$\\kappa$`) %>% 
  select(-c("beta", "Delta", "Design")) %>% 
  filter(`$\\kappa$` %in% (c(0,1,2,3)))

```

[...]
As a notable example, we will discuss the results of design 6 optimized for `r (paste0("$\\lambda = ", good_design$lambda, "$ and $\\kappa = ", good_design$kappa, "$"))`. Under the alternative, this design will have approximately equal average overall and placebo group sample sizes to
design 2 (slightly better, in fact). However, under the null hypothesis, the addition of futility boundaries leads to
an improvement of `r scales::percent(1- good_design$ASN$H0/dlist_tab1$optD_no_futility_fixed_c[[1]]$ASN$H0)`
in overall average sample size
and `r scales::percent(1- good_design$ASNP$H0/dlist_tab1$optD_no_futility_fixed_c[[1]]$ASNP$H0)`
in average placebo group sample size.
[...]


```{r, echo=FALSE, warning=FALSE, message=FALSE}
kbl(fourth_tab_tib, escape = FALSE,  booktabs = TRUE,  linesep = "",
      digits = c(2, 2, rep(0, 6), rep(0, 4), 0, 2), align='c', caption = "\\label{tab_4}Operating characteristics of optimal designs with different penalty factors for the placebo group sample size and different weighting factors for the null hypothesis. See Table \\ref{design_table} for an overview of the differences between design 2 and 6. $\\delta = 0.6, \\Delta = 0.3, \\sigma_T = \\sigma_P = \\sigma_C = 1$. $N_{H_i} = N_{H_i^{TP} \\cap H_i^{TC}}$ and $N_{H_i}^P = N_{H_i^{TP} \\cap H_i^{TC}}^P$ denote the overall / placebo group average sample size under the respective hypotheses for $i \\in \\{0,1\\}$. $CP_{\\min}$ denotes the minimum conditional power.") %>%  pack_rows(index = c(
    "$\\\\bm{1-\\\\beta = 0.8,\\\\text{ design 2}}$" = 1,
    "$\\\\bm{1-\\\\beta = 0.8,\\\\text{ design 6}}$" = 24

    # "$\\\\bm{1-\\\\beta = 0.95, \\\\Delta = 0.1}$" = 9
), escape = FALSE) %>% 
  kable_styling(latex_options="H")
```



# References
